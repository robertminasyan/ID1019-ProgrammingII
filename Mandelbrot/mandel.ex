defmodule Cmplx do
    def new(a, b) do
        {:cx, a, b}
    end

    def add({:cx, a, b}, {:cx, c, d}) do
        {:cx, a + c, b + d}
    end

    def sqr({:cx, a, b}) do
        {:cx, (a * a) - (b * b), 2 * a * b}
    end

    def abs({:cx, a, b}) do
        :math.sqrt((a * a) + (b * b))
    end
end

defmodule Brot do
    def mandelbrot(c, m) do
        z0 = Cmplx.new(0, 0)
        i = 0
        test(i, z0, c, m)
    end

    def test(i, zn, c, m) do
        next = Cmplx.add(Cmplx.sqr(zn), c)
        cond do
        Cmplx.abs(zn) > 2 -> i
        i >= m -> 0
        true -> test(i+1, next, c, m)
        end
    end
end

defmodule Color do
    def convert(depth, max) do
        d = depth
        m = max
        f = d/m
        a = f * 4
        x = trunc(a)
        y = trunc(255 * (a - x))
        case x do
            0 -> {y, 0, 0}
            1 -> {255, y, 0}
            2 -> {255-y, 255, 0}
            3 -> {0, 255, y}
            4 -> {0, 255 - y, 255}
        end
    end

end

defmodule Mandel do
    def mandelbrot(width, height, x, y, k, depth) do
        trans = fn(w, h) ->
            Cmplx.new(x + k * (w - 1), y - k * (h - 1))
        end
        rows(width, height, trans, depth, [])
    end

    def rows(_, 0, _, _, list) do list end
    def rows(width, height, trans, depth, list) do
        row = row(width, height, trans, depth, [])
        rows(width, height-1, trans, depth, [row | list])
    end

    def row(0, _, _, _, row) do row end
    def row(width, height, trans, depth, row) do
        fun = trans.(width, height)
        res = Brot.mandelbrot(fun, depth)
        color = Color.convert(res, depth)
        row(width - 1, height, trans, depth, [color | row])
    end

    def demo() do
        small(-2.6, 1.2, 1.2)
    end
    def small(x0, y0, xn) do
        width = 16000
        height = 9000
        depth = 200
        k = (xn - x0) / width
        image = Mandel.mandelbrot(width, height, x0, y0, k, depth)
        PPM.write("small.ppm", image)
    end
end

defmodule PPM do

  # write(name, image) The image is a list of rows, each row a list of
  # tuples {R,G,B}. The RGB values are 0-255.

  def write(name, image) do
    height = length(image)
    width = length(List.first(image))
    {:ok, fd} = File.open(name, [:write])
    IO.puts(fd, "P6")
    IO.puts(fd, "#generated by ppm.ex")
    IO.puts(fd, "#{width} #{height}")
    IO.puts(fd, "255")
    rows(image, fd)
    File.close(fd)
  end

  defp rows(rows, fd) do
    Enum.each(rows, fn(r) ->
      colors = row(r)
      IO.write(fd, colors)
    end)
  end

  defp row(row) do
    List.foldr(row, [], fn({r, g, b}, a) ->
      [r, g, b | a]
    end)
  end

end